# Создание консольной утилиты с параметрами на Bash
**Тема**: Разработка консольной утилиты на языке Bash для обработки аргументов командной строки
**Цель работы**: Научиться разрабатывать Bash-утилиты с обработкой аргументов командной строки с использованием механизмов getopt или getopts, реализовать функции для различных типов действий и перенаправление потоков вывода и ошибок.
___
1.  Разработать консольную утилиту на языке BASH, которая обрабатывает аргументы командной строки и выполняет следующие действия:

-  для аргументов -u и --users выводит перечень пользователей и их домашних директорий на экран, отсортированных по алфавиту,
- для аргументов -p и --processes выводит перечень запущенных процессов, отсортированных по их идентификатору,
- для аргументов -h и --help выводит справку с перечнем и описанием аргументов и останавливает работу,
- для аргументов -l PATH и –log PATH замещает вывод на экран выводом в файл по заданному пути PATH,
- для аргументов -e PATH и –errors PATH замещает вывод ошибок из потока stderr в файл по заданному пути PATH.

2. Обработка аргументов командной строки должны производиться при  помощи механизмов getopt или getopts.

3. Обработка каждого типа действия должна производится в отдельной функции.

4. Программа должна проверять доступ к пути и выводить соответствующие сообщения об ошибках. При этом программа должна фильтровать или обрабатывать выводы в stderr используемых команд.

5. Задание должно быть выложено на github.
___
### Объяснение работы программы
##### Парсинг аргументов командной строки
Сначала при помощи команды `getopt` разберём аргументы, переданные скрипту. Результат сохраним в переменную `TEMP`.

Ключ `-o` задаёт набор коротких опций, допустимых в командной строке, `--long`  задаёт длинные имена, аналогичные коротким. `-n` задаёт имя программы, которое будет выведено в сообщениях об ошибке, а `$0` и есть имя текущего скрипта. Всё, что стоит после ```--```, трактуется как параметры, переданные скрипту. Мы передаём параметр `$@` - специальную переменную, означающую все аргументы, переданные в скрипт.

Необходимо провести проверку успешного выполнения команды. `$?` - код возврата последней выполненной команды, который, в случае успешного выполнения, будет равен нулю. В случае неудачи, выводим в терминал сообщение об ошибке и принудительно завершаем работу программы.
##### Разбор аргументов
Для начала следует установить позиционные параметры в соответствие с ранее полученной строкой `TEMP`. Это делается при помощи команды `set`, которую необходимо вызвать как bash-код, при помощи команды `eval`.

Также зададим две переменные для последующего хранения названий файлов для перенаправленного вывода.

Для самого разбора аргументов запустим бесконечный цикл с вложенной структурой `case`, в которой в соответствие с аргументами будет исполняться определённый блок кода. При каждой итерации цикла будет производиться сдвиг списка параметров на `1` или `2`. При обнаружении некорректного аргумента будет выведено сообщение об ошибке, а программа принудительно завершится.
##### Выполнение действия в зависимости от выбранной опции
Используя структуру `case`, определим, какую из функций следует вызвать. Если такого действия не найдено, будет выведено сообщение об ошибке, а программа принудительно завершится.
##### Функции
###### show_users()
`awk` - это текстовый анализатор, работающий построчно. Внутри кавычек можно прописать условие соответствующее ему действие. Опция `-F` задаёт разделитель полей по двоеточию.

Задаём условие, что аргумент `$3` (третий столбец, UID пользователя), должен быть `>= 1000`, так как обычно эти значения зарезервированы для обычных пользователей системы.

Также требуется, чтобы `$7` (седьмой столбец, путь к командной оболочке), не соответствовал регулярному выражению, содержащему `nologin` или `false`. Т.е. фильтруются пользователи, у которых нет возможности входа в систему.

Если результат проверки равен истине, выводим в терминал строку, содержащую `$1` - имя пользователя и `$6` - его домашний каталог.
###### show_processes()
`ps` - это команда для получения информации о запущенных процессах. Ключ `-e` задаёт вывод всех процессов системы, а `-o` задаёт, какие именно параметры выводить. Мы выводим поля идентификатор процесса и команду, запустившую процесс (только имя). `--sort=pid` задаёт сортировку по возрастанию по полю PID.
###### show_help()
Отвечает за вывод справки о программе.
###### check_path_access()
Проверяет права доступа к файлу или каталогу перед выполнением операций чтения или записи.

Для проверки возможности записи извлекаем путь к директории из полного пути и ключами `-d` и `-w` в условии проверяем, существует ли каталог и можно ли в него писать соответственно.

Для проверки возможности чтения файла, осуществляем проверку с ключом `-r` - возвращает `true` если текущий пользователь имеет право на чтение.

В случае ложного результата любого из условий, будет выведено сообщение об ошибке, а программа принудительно завершится.
##### Полный код программы
```Bash
#!/bin/bash

show_users() {
    echo "Список пользователей и их домашние директории:"
    awk -F: '$3 >= 1000 && $7 !~ /(nologin|false)/ {print $1 " -> " $6}' /etc/passwd | sort
}

show_processes() {
    echo "Список процессов (PID : команда):"
    ps -eo pid,comm --sort=pid
}

show_help() {
    cat <<EOF
Использование: $0 [ОПЦИИ]

Доступные аргументы:
  -u, --users         Вывести список пользователей и их домашние директории
  -p, --processes     Вывести список запущенных процессов
  -l PATH, --log PATH Перенаправить стандартный вывод (stdout) в файл PATH
  -e PATH, --errors PATH Перенаправить поток ошибок (stderr) в файл PATH
  -h, --help          Вывести эту справку и завершить выполнение

Примеры:
  $0 -u
  $0 --processes --log processes.txt
  $0 -u -l out.txt -e err.txt
EOF
}

check_path_access() {
    local path="$1"
    local mode="$2"

    if [[ "$mode" == "w" ]]; then
        local dir
        dir=$(dirname "$path")
        if [[ ! -d "$dir" || ! -w "$dir" ]]; then
            echo "Ошибка: нет прав на запись в '$dir'" >&2
            exit 1
        fi
    elif [[ "$mode" == "r" ]]; then
        if [[ ! -r "$path" ]]; then
            echo "Ошибка: нет прав на чтение '$path'" >&2
            exit 1
        fi
    fi
}

# ---

TEMP=$(getopt -o upl:e:h --long users,processes,log:,errors:,help -n "$0" -- "$@")
if [[ $? != 0 ]]; then
    echo "Ошибка: неверные аргументы. Используйте --help для справки." >&2
    exit 1
fi

eval set -- "$TEMP"

LOG_FILE=""
ERR_FILE=""

while true; do
    case "$1" in
        -u|--users)
            ACTION="users"
            shift
            ;;
        -p|--processes)
            ACTION="processes"
            shift
            ;;
        -l|--log)
            LOG_FILE="$2"
            check_path_access "$LOG_FILE" "w"
            exec >"$LOG_FILE"
            shift 2
            ;;
        -e|--errors)
            ERR_FILE="$2"
            check_path_access "$ERR_FILE" "w"
            exec 2>"$ERR_FILE"
            shift 2
            ;;
        -h|--help)
            show_help
            exit 0
            ;;
        --)
            shift
            break
            ;;
        *)
            echo "Неизвестный аргумент: $1" >&2
            exit 1
            ;;
    esac
done

case "$ACTION" in
    users)
        show_users
        ;;
    processes)
        show_processes
        ;;
    *)
        echo "Не указано действие. Используйте -h для справки." >&2
        exit 1
        ;;
esac
```
